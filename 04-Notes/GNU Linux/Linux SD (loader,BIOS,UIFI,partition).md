*21-08-2025 16:51*
### Status: 
#sub-particle 
### Tags: [[Linux]],[[theoretical knowledge]],[[Operating system]]

# Linux SD

![[Pasted image 20250821165646.png]]

As you can see, I have a disk drive and a 20 GB disk connected here, which has been named sda. However, the names given by udev—sda, sdb, etc.—are not permanently assigned to the disks. Each time you start the system or connect devices, udev assigns names in order. Yes, there is an order in which devices are detected, and often the same disks will be named the same, but in no case should you rely on these names. Let's say you have 3 disks - sda, sdb, and sdc, and you reconnect them, or one stops working - then sdc will start to be called sdb. In theory, this can lead to data loss. How? We will discuss this later. Just remember that you should not rely on these letters.

From the topic “About file systems,” we learned that in order to create, store, modify, and generally work with files on a disk, we need a file system. To do this, we can write it to the disk. In principle, this scheme will work, but in general it is inconvenient and can create problems for us in the future. For example, in the future we may need to reinstall the system. This usually involves deleting the old file system and creating a new one, which is called formatting the file system. However, this will also delete all the files that we would like to transfer to the new system. Of course, we could transfer everything to a flash drive beforehand and then transfer it back, but this is unnecessary work and a waste of time.You may know how to avoid this problem—on Windows, you can have a D drive where you store your files, and when you format the drive, this data is not deleted because only the file system on the C drive is deleted. On GNU/Linux, user files are stored in the /home directory, so you just need to separate /home from the root. That is, it is assumed that you have two file systems on one disk. To do this, you need to divide the disk into so-called partitions and write your file system to each partition. But in order for the computer to know where one partition begins, where it ends, and where another begins, you need a special place at the beginning of the disk where this information is specified – the partition table.
![](https://basis.gnulinux.pro/ru/latest/_images/mbr.png)

There are different types of partition tables: MBR, also known as DOS or MS-DOS; GPT; Apple and BSD have their own partition tables; there are others, but we are not interested in them; you will mainly be dealing with MBR and GPT. The abbreviation MBR has another meaning – master boot record – and the partition table itself is stored inside this record. The MBR boot record was necessary for computers in the past. The fact is that computers used to have a BIOS chip, which contained a number of microprograms, and, among other things, the BIOS was responsible for turning on the computer. But the BIOS was very limited—it had to be no more than a dozen kilobytes, it had a maximum of a megabyte of RAM available—and under such conditions, you can't do much. And the BIOS had to ultimately load the operating system – but with such limitations, it was impossible to add support for any file system or program that loads the operating system. Moreover, operating systems are different, each has its own file system, and each has to be loaded in its own way. Therefore, the BIOS simply accessed the zero sector of the hard drive, where the master boot record (MBR) was located. And there we had the operating system boot loader and the partition table. At the same time, the MBR itself was also limited – only 512 bytes, of which 446 bytes were for the boot loader and 64 for the partition table. Looking ahead, I will say that the first 63 sectors remained free, which is where the main part of the boot loader is located, not just these 446 bytes, but that is a topic for another time.

So, the MBR gives us 64 bytes to store all the information about the partitions. And each partition requires 16 bytes of information. The result is 4 partitions. Then the extended boot record (VBR) appeared, which made it possible to create extended partitions that allowed the 4-partition limit to be bypassed. Roughly speaking, instead of the partition record itself, a link to another table was specified, which indicated additional partitions. Also, it would not be possible to specify partitions larger than 2 TB in the MBR partition table, since the address does not fit in the table. As a result, the BIOS, with its limitations, created a lot of problems with forced workarounds.In the 2000s, they decided to get rid of these limitations and created a new standard – UEFI. Here, they really went wild—UEFI can weigh tens of megabytes, understands file systems, can work with networks, and has a graphical interface. More precisely, all of this can be implemented in UEFI, but not every manufacturer does so, except for some standard functionality. And, of course, there is no longer any need for a boot loader in MBR—why limit yourself to 446 bytes when you can add file system support to UEFI, where a full-fledged boot loader will reside? Plus, disk sizes are growing, so MBR has been replaced by GPT.There is no longer any need to keep the boot loader in the boot sector—UEFI uses a special EFI partition with the FAT32 file system for this purpose. The 2 TB limit has also been removed; GPT has a theoretical limit of almost 10 zettabytes. As for the number of partitions, they are essentially unlimited, except for the operating system, but even then we are talking about 128 partitions, which is more than enough. However, for compatibility purposes, UEFI allows the bootloader to be installed in the zero sector, as was the case with MBR.


# References:

- [[Linux working with SD(Storage device)]]
  